MySQL配置文件路径：cat /etc/mysql/mysql.conf.d/mysqld.cnf

查看错误日志文件：show  variables like '%log_error%';
    查看log_error文件就行

二进制日志：二进制日志（BINLOG）记录了所有DDL(数据定义语言/创建表，库)语句和DML（增删改）语句，但不包括数据查询（SELECT, SHOW）
    show variables like '%log_bin%'
    log_bin 二进制日志是否开启
    log_bin_basename 二进制文件
    log_index  索引信息

    STATEMENT 基于sql语句的日志记录，记录的是sql语句，对数据进行修改的sql都会记录再日志文件中
    ROW 基于行的日志记录，记录的是每一行的数据变更（默认）
    MIXED 混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些情况下会自动切换为ROW进行记录
    设置格式：
        vim /etc/my.conf 添加语句：binlog_format=statement
        重启mysql服务：systemctl restart mysqld
    show variables like '%binlog_format%'

    二进制查看工具：由于日志是以二进制方式存储，不能直接读取，需要通过二进制查询工具mysqlbinlog来查看：
    mysqlbinlog 【参数选项】logfilename
        -d 指定数据库名称，只列出指定数据库相关操作
        -o 忽略日志前n行命令
        -v 将行事件重构为SQL语句
        -w 将行事件重构sql语句，并标注注释信息
    注意：如果是ROW格式，需要添加-v选项，是底层mysql 的更新格式，如果使用格式是statement格式，不需要添加-v选项，展示的是当时调用的sql语句

# 日志删除
    对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清楚，将会占用大量的磁盘空间，可以通过一下几种方式清理日志
    reset master 删除全部的binlog日志，删除之后，日志编号将从binlog.000001重新开始
    purge master logs to 'binlog.******' 删除******编号之前的所有日志
    purge master logs before 'yyyy-mm-dd hh24:mi:ss'删除日志为'yyyy-mm-dd hh24:mi:ss'之前产生的所有日志

    可以在mysql的配置文件中配置二进制日志的过期时间，设置之后，二进制日志过期会自动删除
    show variables like '%binlog_expire_logs_seconds%'
    show variables like '%binlog_expire%'

查询日志：
    查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的sql语句，默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置一下配置
    show variables like '%general%';

    修改MySQL的配置文件/etc/my.conf文件添加如下内容
    general_log = 1
    general_log_file=mysql_query.log

慢查询日志：
    慢查询日志记录了所有执行时间超过参数long_query_time设置值并且扫描记录数不小于min_examined_row_limit的所有SQL语句的日志，默认未开启。long_query_time默认设置为10s，最小可0，精度可到微秒
    slow_query_log=1 #慢查询日志开关
    long_query_time=2 #执行时间参数

    默认情况，不会记录管理语句，也不会记录不适用索引进行查找的查询需要更改此行为需要更改配置
    #记录执行较慢的管理语句
    log_slow_admin_statements=1
    #记录执行较慢的未使用索引的语句
    log_queries_using_indexes=1

主从复制：
    概述：主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步
    主库（Master）  -->  从库（Slave）
    MySQL复制的主要特点包含以下三个方面：
        主库出现问题，可以快速切换到从库提供服务
        实现读写分离，降低主库的访问压力
        可以在从库中执行备份，以避免备份期间影响主库服务