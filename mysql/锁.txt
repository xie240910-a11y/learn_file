锁分类：MYSQL中的锁分三类
    全局锁：锁定数据库中的所有表
    表级锁：每次操作锁住整张表
    行级锁：每次操作锁住对应的行数据

全局锁：全局锁是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句；DDL语句，已经更新操作的事务语句提交语句都会被阻塞。典型使用场景是全库逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性；
    全局锁：flush tables with read lock;
    备份数据库：mysqldump (-h 主机地址) -uroot -p1234 itcast>itcast.sql
    解锁：unlock tables;
    
    特点：数据库中加全局锁，是比较重的操作，存在一下问题
        1、如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就停摆
        2、如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。
        在InnoDB引擎中，我们可以在备份时加上参数 --single-transcation参数来完成不加锁的一致性数据备份

表级锁：表级锁每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM,InnoDB,BDB等存储引擎中。
    1、表共享读锁 (read lock 读锁能读取数据，但是无法写入数据，其他用户连接操作表也会阻塞)
    2、表独占写锁（write lock 当前连接能读能写，其他连接无法读写，会阻塞）
    语法：
        加锁：lock tables 表名 read/write;
        释放锁：unlock tables;
    
    元数据锁（meta data lock MDL）：MDL加锁过程是系统自动控制，无需显示使用，在访问一张表自动加上。MDL锁主要作用是维护表元数据的一致性，在表上有活动事务时候，不可以对元数据进行写入操作
        lock tables xxx read/write                   SHARED_READ_ONLY / SHARED_NO_READ_WRITE
        select/selct  ... lock in share mode         SHARED_READ
        insert、update、delete、select ...for update  SHARED_NO_READ_WRITE
        alter table...                               EXCLUSIVE 与其他的MDL都互斥
    元数据锁使用：A,B客户端打开mysql，A开启事务调用sql未提交commit时，B客户端使用alter table时会阻塞
    
    意向锁：表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查
        意向共享锁（IS）: 与表锁共享锁（read）兼容，与表锁排他锁（write）互斥
        意向排他锁（IX）: 与表锁共享锁（read）与表锁排他锁（write）都互斥。意向锁之间不会互斥
    检查加锁情况：
    select object_schema,  object_name, index_name, lock_type, lock_type, lock_mode, lock_data from performance_schema.data_locks;

    例子：
    A客户端:
        begin; 开启事务
        select * from score where id = 1 lock in share mode; 加行锁跟意向共享锁；

    B客户端：
        select object_schema,  object_name, index_name, lock_type, lock_type, lock_mode, lock_data from performance_schema.data_locks;
        lock tables socre read;成功，兼容
        lock tables socre write;失败，不兼容
    -------------------------------------
    A客户端:
        begin; 开启事务
        update score set math = 66 where id = 1; 加行锁跟意向排他锁；

    B客户端：
        select object_schema,  object_name, index_name, lock_type, lock_type, lock_mode, lock_data from performance_schema.data_locks;
        lock tables socre read;失败，不兼容
        lock tables socre write;失败，不兼容

    行级锁：行级锁每次操作锁住对应行数据。锁定粒度小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。
        InnoDB的数据是基于索引组织的，行锁是通过对应索引上的索引项加锁来实现的，而不是记录加的锁。对于行级锁有三类：
            行锁：锁定单行记录，防止其他事务对此行进行update跟delete，在RC,RR隔离级别下都支持
            间隙锁：锁住索引记录间隙，保证索引间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持
            临建锁：行锁跟间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap，在RR隔离级别下支持

        行锁：InnoDB实现了两种类型的行锁
            共享锁（S）允许一个事务去读一行，阻止其他事务获取相同数据集的排他锁
            排他锁（X）允许获取排他锁的事务更新数据，阻止其他事务获取相同数据集的共享锁跟排他锁
            SQL                             行锁类型：          说明：
            INSERT                          排他锁              自动加锁
            UPDATE                          排他锁              自动加锁
            DELETE                          排他锁              自动加锁
            SELECT                          不加任何锁           
            SELECT LOCK IN SHARE MODE       共享锁              需要手动在SELECT之后加LOCK IN SHARE MODE
            SELECT ... FOR UPDATE           排他锁              需要在手动SELECT之后加FOR UPDATE
        A与B客户端都使用lock in share mode是兼容的，但是A创建共享锁在B创建排他锁update 会阻塞
        排他锁之间也是互斥的

        间隙锁/临建锁：默认情况下, InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索跟索引扫描，以防止幻读
            索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁
                例子： A客户端更新不存在的数据id=5时，会将表中数据id为3跟id为7的数据锁住，如果同一时间B客户端插入id为6的数据无法插入，因为存在间隙锁
            索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁
                例子：查询A客户端的数据条件是普通索引：select * from stu where age = 3 lock in share mode;注意加共享锁时，会产生间隙锁避免幻读
            索引上的范围查询（唯一索引）--会访问到不满足条件的第一个值为止
                例子：select * from stu where id >= 19 lock in share mode;锁住19到比他大的第一个值生成间隙锁，比他无穷大加间隙锁避免幻读
            注意：间隙锁唯一目的是防止其他事务插入间隙 
        